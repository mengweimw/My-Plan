[TOC]

# 4. 类和对象

C++面向对象的三大特性为：**封装、集成和多态**；

C++认为**万事万物都皆为对象**，对象上有其属性和行为

**例如：**

1. 人可以作为对象，属性有姓名、年龄、身高、体重...，行为有走、跑、跳、吃饭、唱歌...
2. 车也可以作为对象，属性有轮胎、方向盘、车灯...，行为有载人、放音乐、开空调...
3. 具有相同性质的对象，我们可以抽象为类，人属于人类，车属于车类

## 4.1 封装

### 4.1.1 封装的意义

封装是C++面向对象三大特性之一

封装的意义：

	1. 将属性和行为作为一个整体，表现生活中的事务；
	1. 将属性和行为加以权限控制；

**封装意义一：**

​	在设计类的时候，属性和行为写在一起，表现事务；

**语法：** `class  类名 { 访问权限； 属性 / 行为 }`

**示例1**： 设计一个圆类，求圆的周长

**示例代码：**

```c++
#include <iostream>
using namespace std;

const double PI = 3.1415926;    //!< PI

//!< 设计一个圆类，求圆的周长
//!< 圆求周长的公式 2 * PI * 半径


//!< class代表要设计一个类，类后面紧跟着类的名称
class Circle {
    //!< 访问权限
public:     //!< 公共权限
    //!< 属性，用变量
    double m_r; //!< 半径
    //!< 行为，用函数
    double calculateZC()
    {
        return 2 * PI * m_r;
    }
} ;

int main()
{
    //!< 通过圆类创建一个具体的对象，圆（对象）
    Circle circle;
    circle.m_r = 10000;

    cout << "ZC: " << circle.calculateZC() << endl;

    return 0;
}
```

**示例2：**

设计一个学生类，属性有姓名和学号，可以给姓名和学号复制，可以显示学生的姓名和学号

```c++
#include <iostream>
#include <string>
using namespace std;

class Student 
{
public:
    string name;        //!< 姓名
    string id;          //!< 学号


    void setStudent(string in_name, string in_id)
    {
        name = in_name;
        id = in_id;
    }
    void showStudent()
    {
        cout << "name: " << name << "   id: " << id << endl;
    }
};

int main()
{
    Student stu;
    stu.setStudent("mengwei", "1881120011");
    stu.showStudent();

    return 0;
}
```

### 4.1.2 封装的意义二

类在设计时，可以把属性和行为放在不同的权限下，加以控制

访问权限有三种：

1. public：公共权限， 类内可以访问，类外也可以访问
2. protected：保护权限，类内可以访问，类外不可以访问
3. private：私有权限，类内可以访问，类外不可以访问

```c++
#include <iostream>
#include <string>
using namespace std;


//!< 访问权限：
//!< 公共权限 public: 成员在类内可以访问，类外也可以访问
//!< 保护权限 protected: 成员在类内可以访问，类外不可以访问，儿子可以访问父亲中的保护的内容
//!< 私有权限 private: 成员在类内可以访问，类外不可以访问，儿子不可以访问父亲的私有内容

class Person
{
public:
    string m_name;
protected:
    string m_car;
private:
    string m_password;

public:
    void initInformation()
    {
        m_name = "zhangsan";            //!< 公共权限，类内可以访问
        m_car = "BYD";                  //!< 保护权限，类内可以访问
        m_password = "123456";          //!< 私有权限，类内可以访问
    }
};

int main()
{
    Person p1;
    p1.initInformation();
    p1.m_name = "lisi"; 
    // p1.m_car = "jike";       //!< 保护权限，类外不可以访问
    // p1.m_password = "111";   //!< 私有权限，类外不可以访问

    return 0;
}
```

### 4.1.3 struct 和 class 的区别

1. struct 的默认权限是public
2. class的默认权限是private

```c++
#include <iostream>
#include <string>
using namespace std;

//!< struct 和 class的区别
//!< struct 默认是公共权限，public
//!< class 默认是私有权限，private

class C1
{
    int m_A;    //!< 默认权限是private
};

struct C2
{
    int m_A;    //!< 默认权限是public
};

int main()
{
    C1 c1;
    // c1.m_A = 100;    //!< 类外不可访问

    C2 c2;
    c2.m_A = 100;       //!< 类外可以访问

    return 0;
}
```

### 4.1.4 将成员属性设置为私有

**优点1**：将所有成员属性设置为私有，可以自己控制读写权限

**优点2：**对于写权限，我们可以检测数据的有效性；

```c++
#include <iostream>
#include <string>
using namespace std;

//!< 成员属性设置为私有
//!< 1. 可以自己控制读写权限
//!< 2. 对于写可以检测数据的有效性
class Persom
{
public:
    void setName(string name)
    {
        m_name = name;
    }
    string getName()
    {
        return m_name;
    }

    void setAge(int age)
    {
        if (0 > age || 150 < age)
        {
            cout << "set age is " << age << " invalid" << endl;
            m_age = 0;
        } else {
            m_age = age;
        }
    }
    //!< 获取年龄，可读可写，如果想修改（年龄的范围必须是0~150之间）
    int getAge()
    {
        // m_age = 100;
        return m_age;
    }

    void setLover(string lover)
    {
        m_Lover = lover;
    }
    // string getLover()
    // {
    //     return m_Lover;
    // }

    // void showInformation()
    // {
    //     cout << "m_name: " << m_name << " m_age: " << m_age << " m_Lover: " << m_Lover << endl; 
    // }

private:
    //!< name，可读可写
    string m_name;
    //!< age，只读
    int m_age;
    //!< 情人，只写
    string m_Lover;


};

int main()
{
    Persom p1;
    p1.setName("zhangsan");
    cout << "name: " << p1.getName() << endl;

    p1.setAge(100);
    cout << "age: " << p1.getAge() << endl;

    p1.setLover("Lover");

    return 0;
}
```



### 4.1.5 练习案例：

设计一个立方体类（Cube）

求出立方体的面积和体积

分别用全局函数和成员函数判断两个立方体是否相等

```c++
#pragma once
#include <iostream>
using namespace std;

class Point
{
private:
    int m_X;      //!< X坐标
    int m_Y;      //!< Y坐标
public:
    void setX(int X);
    int getX();
    void setY(int Y);
    int getY();

};
```



```c++
#pragma once
#include <iostream>
#include "point.h"
using namespace std;

//!< 定义圆类
class Circle
{
private:
    int m_R;         //!< 圆的半径
    Point m_center;            //!< 圆心
public:
    void setm_R(int R);
    int getm_R(void);
    void setCenter(Point center);
    Point getCenter();
};
```



```c++
#include "point.h"


void Point::setX(int X)
{
    m_X = X;
}
int Point::getX()
{
    return m_X;
}
void Point::setY(int Y)
{
    m_Y = Y;
}
int Point::getY()
{
    return m_Y;
}
```



```c++
#include "circle.h"


void Circle::setm_R(int R)
{
    m_R = R;
}

int Circle::getm_R(void)
{
    return m_R;
}
void Circle::setCenter(Point center)
{
    m_center = center;
}
Point Circle::getCenter()
{
    return m_center;
}
```



```C++
#include "circle.h"

//!< 判断点和圆的关系
void isInCircle(Circle& c, Point& p)
{
    //!< 计算两点之间距离，平方
    int distance = (c.getCenter().getX() - p.getX()) * (c.getCenter().getX() - p.getX())  + 
                   (c.getCenter().getY() - p.getY()) * (c.getCenter().getY() - p.getY());

    int rDistance = c.getm_R() * c.getm_R();

    if (distance > rDistance)
    {
        cout << "Point out circle" << endl;
    }
    else if (distance == rDistance)
    {
        cout << "Point on circle" << endl;
    }
    else
    {
        cout << "Point in circle" << endl;
    }

    return;
}

int main()
{
    Circle c;
    c.setm_R(10);
    //!< 在类中，可以让另一个类作为本类中的成员
    Point center;
    center.setX(10);
    center.setY(0);
    c.setCenter(center);

    Point p;
    p.setX(10);
    p.setY(110);

    isInCircle(c, p);

    return 0;

}
```



## 4.2 对象的初始化和清理

### 4.2.1 构造函数和析构函数

对象的**初始化和清理**也是两个非常重要的安全问题；

​	一个对象或者变量没有初始状态，对其使用后果是未知的；

​	同样的使用完一个对象或变量，没有及时清理，也会造成一定的安全问题；



C++ 利用了**构造函数** 和 **析构函数**解决和上述问题，这两个函数将会被编译器自动调用，完成对象的初始化和清理工作；

对象的初始化和清理工作是编译器强制要我们做的事情，因此如果 **我们不提供构造和析构函数，编译器会提供，编译器提供的构造函数和析构函数是空实现**。

1. 构造函数：主要作用在于创建对象时为对象的成员属性赋值，构造函数由编译器自动调用，无须手动调用。
2. 析构函数：主要作用与对象 **销毁前**系统自动调用，执行一些清理工作。



**构造函数语法**： `类名() {}`

1. 构造函数，没有返回值也不写void；
2. 函数名称和类名相同；
3. 构造函数可以有参数，因此可以发生重载
4. 程序在调用对象时候会自动调用构造，无须手动调用，而且只会调用一次；

**析构函数语法**：`~类名() {}`

1. 析构函数，没有返回值也不写void
2. 函数名称与类名相同，在名称前加上符号~
3. 析构函数不可以有参数，因此不可以发生重载
4. 程序在对象销毁前会自动调用析构函数，无须手动调用，而且只会调用一次

```c++
#include <iostream>
using namespace std;

class Person
{
public:
    Person()
    {
        cout << "Person creator called" << endl;
    }

    ~Person()
    {
        cout << "~Person destory called" << endl;
    }
};

void test01()
{
    Person p;
}

int main()
{
    test01();

    return 0;
}   
```

### 4.2.2 构造函数的分类及调用

两种分类方式：

	1. 按参数分为：有参构造和无参构造；
	1. 按类型分为：普通构造和拷贝构造；

三种调用方式：

	1. 括号法
	2. 显示法
	1. 隐式转换法

```c++
#include <iostream>
using namespace std;

class Person 
{
public:
    /** 构造函数的分类  */
    //!< 无参构造函数 或 默认构造函数
    Person()
    {
        cout << "No param creator!" << endl;
    }

    //!< 有参构造函数
    Person(int a)
    {
        age = a;
        cout << "Has param creator!" << endl;
    }

    //!< 拷贝构造函数，形参为：引用常量，不可以修改此数据
    Person(const Person& p)
    {
        //!< 将传入的人身上的所有属性，copy到此人的身上
        age = p.age;
        cout << "Copy creator" << endl;
    }

    ~Person()
    {
        cout << "Destory Persom" << endl;
    }
    int getAge()
    {
        return age;
    }

private:
    int age;
};

//!< 调用
//!< 括号法
//!< 分类法
//!< 隐式转换法
void test01()
{
    //!< 括号法
    Person p1;   //!< 默认构造函数
    Person p2(100); //!< 调用有参构造函数
    Person p3(p2);
    //!< 注意：
    //!< 1. 调用默认构造函数时候，不要加()，
    // Person p1();     //!< 此处不会创建对象，因为编译器会认为这是一个函数的声明
    cout << "p2 age: " << p2.getAge() << endl;
    cout << "p3 age: " << p3.getAge() << endl;
    
    //!< 显示法
    Person p4;                  //!< 无参
    Person p5 = Person(100);    //!< 有参
    Person p6 = Person(p5);     //!< 显示

    Person(100);  //!< 匿名对象，特点：当前行执行结束后，系统会立即回收掉匿名对象
    //!< 注意：
    //!< 2. 不要使用拷贝构造函数来初始化匿名对象，编译器会认为 Persion(p5) === Person p5; 编译器会认为这是一个变量声明
    // Person(p5);      //!< 会报重定义

    //!< 隐式转换法
    Person p6 = 10;     //!< 相当于写了 Person p6 = Person(10);     有参构造
    Person p7 = p6;     //!< 相当于写了 Person p7 = Person(p6);     有参构造

}

int main()
{
    test01();

    return 0;
}
```

### 4.2.3 拷贝构造函数的调用时机

C++中拷贝构造函数的调用时机通常有三种：

1. 使用一个已经创建完毕的对象来初始化一个新对象；
1. 值传递的方式给函数参数传值；
1. 以值方式返回局部对象

```c++
#include <iostream>
using namespace std;

//!< 拷贝构造函数的调用时机

class Person
{
public:
    Person()
    {
        cout << "No param creator" << endl;
    }

    Person(int age)
    {
        m_age = age;
        cout << "Has param creator" << endl;
    }

    Person(const Person& p)
    {
        m_age = p.m_age;
        cout << "Copy creator" << endl;
    }

    ~Person()
    {
        cout << "Destory" << endl;
    }

    int m_age;
};

//!< 使用一个已经创建完毕的对象初始化一个新的对象
void test01()
{
    Person p1;
    p1.m_age = 100;

    Person p2(p1);
    cout << "p1 age " << p1.m_age << " p2 age " << p2.m_age << endl;

    p2.m_age = 99;
    cout << "p1 age " << p1.m_age << " p2 age " << p2.m_age << endl;

    return;
}

void doWork(Person p)
{
    p.m_age = 1000;
    cout << "doWork p.m_age " << p.m_age << endl;
}

//!< 值传递的方式给函数参数传值
void test02()
{
    Person p(100000);
    doWork(p);
    cout << "test02 p.m_age " << p.m_age << endl;
}

Person doWork2()
{
    Person p1(1000);
    cout << "int* " << &p1 << endl;
    return p1;
}

//!< 以值方式返回局部对象
void test03()
{
    Person p = doWork2();
    cout << "test 03 p.m_age " << p.m_age << endl;
    cout << "test 03 p.m_age " << p.m_age << endl;
    cout << "int* " << &p << endl;
}


int main()
{
    // test01();
    test02();
    test03();

    return 0;
}
```

### 4.2.4 构造函数的调用时机

默认情况下，C++编译器至少给一个类添加三个函数:

1. 默认构造函数（无参，函数体为空）

2. 默认析构函数（无参，函数体为空）

3. 默认拷贝构造函数，对属性进行值拷贝

   

   构造函数的调用规则：

   1. 如果用户定义有参构造函数，c++不再提供默认构造函数，但是会提供默认拷贝构造函数；
   2. 如果用户定义了拷贝构造函数，c++不会再提供其他构造函数

   ```c++
   #include <iostream>
   using namespace std;
   
   //!< 构造函数的调用规则
   //!< 创建一个类，C++会默认添加三个函数
   //!< 默认构造函数（空实现）
   //!< 默认析构函数（空实现）
   //!< 拷贝构造函数（值拷贝）
   
   //!< 如果我们写了有参构造函数，编译器就不会提供默认构造，但是会提供拷贝构造
   //!< 如果我们写了拷贝构造函数，编译器就不会提供其他的普通构造函数（无参和有参）
   
   class Person
   {
   public:
       Person()
       {
           cout << "Default creator called" << endl;
       }
   
       Person(int age)
       {
           cout << "Has param creator called" << endl;
       }
   
       //!< 编译器会实现默认拷贝构造函数，不用我们自己来实现
       // Person(const Person& p)
       // {
       //     m_age = p.m_age;
       //     cout << "Copy creator called" << endl;
       // }
   
       ~Person()
       {
           cout << "Default destory called" << endl;
       }
   
       int m_age;
   };
   
   void test01()
   {
       Person p;
       p.m_age = 19;
   
       Person p2(p);
       cout << "p2 age " << p2.m_age << endl;
   }
   
   int main()
   {
       test01();
   
       return 0;
   }
   ```

### 4.2.5 深拷贝和浅拷贝

深拷贝是面试经典问题，也是常见的一个坑

浅拷贝：简单的赋值拷贝操作

深拷贝：在堆区重新申请空间，进行拷贝操作

**总结：如果属性有在堆区开辟的，一定要自己提供析拷贝构造函数，防止浅拷贝的问题**

```c++
#include <iostream>
using namespace std;

class Person
{
public:
    Person()
    {
        cout << "Person default creator called" << endl; 
    }

    Person(int age, int height)
    {

        m_age = age;
        m_height = new int(height);
        
        cout << "Person has param creator called" << endl;
    }

    //!< 自己实现深拷贝
    Person(const Person& p)
    {
        cout << "Person copy creator called" << endl;
        m_age = p.m_age;

        m_height = new int(*p.m_height);
    }

    ~Person()
    {
        //!< 将堆区申请的数据，在此处释放掉
        if (NULL != m_height) {
            delete m_height;
            m_height = NULL;
        }
        cout << "Person destory called" << endl;
    }

    int m_age;
    int* m_height;
};

void test01()
{
    Person p1(18, 160);

    cout << "P1 age " << p1.m_age << " P1 height " << *p1.m_height << endl;

    //!< 编译器浅拷贝
    Person p2(p1);
    cout << "P2 age " << p2.m_age << " P2 height " << *p2.m_height << endl;
}

int main()
{
    test01();

    return 0;
}
```

### 4.2.5 初始化列表

**作用：**

C++提供了初始化列表语法，用来初始化属性

**语法：**	`构造函数():属性1(值1), 属性2(值2) ... {}`

```c++
#include <iostream>
using namespace std;

class Person
{
public:
    Person():m_a(1000), m_b(2000), m_c(3000)
    {
        cout << "No param creator called" << endl;
    }

    //!< 有参构造的初始化列表
    Person(int a, int b, int c):m_a(a), m_b(b), m_c(c)
    {
        cout << "Has param creator called" << endl;
    }
    
    ~Person()
    {
        cout << "Destory called" << endl;
    }

    int m_a;
    int m_b;
    int m_c;
};

void test01()
{
    Person p(1, 2, 3);
    cout << "m_a: " << p.m_a << " m_b " << p.m_b << " m_c " << p.m_c << endl; 

    Person p1(p);
    cout << "m_a: " << p1.m_a << " m_b " << p1.m_b << " m_c " << p1.m_c << endl; 

    Person p2;
    cout << "m_a: " << p2.m_a << " m_b " << p2.m_b << " m_c " << p2.m_c << endl; 

    Person p3(p2);
    cout << "m_a: " << p3.m_a << " m_b " << p3.m_b << " m_c " << p3.m_c << endl; 
}

int main()
{
    test01();

    return 0;
}
```

### 4.2.6 类对象作为类的成员

C++类中的成员可以是另一个类的对象，我们称该成员为对象成员

例如：

```c++
class A 
{
	
}
class B
{
	A a;
}
```

B 类中有对象A作为成员，A为对象成员。

那么当创建B对象时，A与B的构造和析构的顺序谁先谁后？

```c++
#include <iostream>
using namespace std;

// class Student
// {
// public:
//     Student()
//     {
//         cout  << "Student no param creator called" << endl;
//     }
//     ~Student()
//     {
//         cout  << "Student destory called" << endl;
//     }
//     int age;
// };


// class Person
// {
// public:
//     Person ()
//     {
//         cout  << "Person no param creator called" << endl;
//     }
//     ~Person()
//     {
//         cout << "Person destory called" << endl;
//     }
//     Student stu;
// };


class Phone
{
public:
    Phone(string name):m_Name(name)
    {
        cout << "Phone has param creator called" << endl;
    }

    ~Phone()
    {
        cout << "Phone destory called" << endl;
    }
    string m_Name;
};

class Person
{
public:
    Person(string name, string phoneName):m_name(name), phone(phoneName)
    {
        cout << "Person has param creator called" << endl;
    }
    ~Person()
    {
        cout << "Person destory called" << endl;
    }

    string m_name;
    Phone phone;
};

//!< 当其他类对象作为类成员，构造的时候，先构造对象，再构造自身
//!< 析构函数相反，先析构对象，再析构自身
void test01()
{
    Person p("zhangsan", "iphone14_max");
    cout << "Person name: " << p.m_name << " Phone name: " << p.phone.m_Name << endl;
}

int main()
{
    test01();

    return 0;
}
```

### 4.2.7 静态成员

静态成员就是在成员变量和成员函数前加上关键字static，成为静态成员

静态成员分为：

1. 静态成员变量：
   1. 所有对象共享同一份数据
   2. 在编译阶段分配内存
   3. 类内声明，类外初始化
2. 静态成员函数
   1. 所有对象共享一个函数
   2. 静态成员函数只能访问静态成员变量

**示例1**：静态成员变量

```c++
#include <iostream>
using namespace std;

class Person
{
public:
    //!< 1. 所有对象共享同一份数据
    //!< 2. 编译阶段就分配了内存
    //!< 3. 类内声明，类外初始化
    static int m_age;
private:
    //!< 静态成员变量也是有访问权限的
    static int m_B;

};

//!< 类外初始化
int Person::m_age = 100;
// int Person::m_B = 200;  //!< 类外无法访问私有静态成员变量

void test01()
{
    Person p;
    cout  << p.m_age << endl;

    Person p2;
    p2.m_age = 200;
    cout  << p.m_age << endl;
}

void test02()
{
    //!<  静态成员变量不属于某个对象上，所有对象共享同一份数据
    //!<  因此静态成员变量有两种访问方式：
    //!< 1. 通过对象访问
    Person p;
    cout << p.m_age << endl;
    //!< 2. 通过类名访问
    cout << Person::m_age << endl;
}

int main()
{
    test01();
    test02();

    return 0;
}
```



**示例2**：静态成员函数

```c++
#include <iostream>
using namespace std;


class Person
{
public:
    static int m_a;
    int m_b;

    //!< 所有对象共享同一个函数
    //!< 静态成员函数只能访问静态成员变量
    static int func()
    {
        cout << "static int func called" << endl;
        m_a = 99;
        cout << "m_a " << m_a << endl;
        // m_b = 100;  //!< 静态成员函数不能访问非静态的成员变量，无法区分哪个对象的m_b属性
        return 0;
    }

private:
    //!< 静态成员函数也是有访问权限的
    static void func2()
    {
        cout << "static int func2 called" << endl;
        return;
    }
};

int Person::m_a = 10000;

void test01()
{
    //!< 通过对象访问
    Person p;
    p.func();
    //!< 通过类名访问
    Person::func();

    // Person::func2(); //!< 类外不能访问私有属性的静态成员函数
}

int main()
{
    test01();

    return 0;
}
```

## 4.3 C++对象模型和this指针

### 4.3.1 成员变量和成员函数分开存储

在C++中，类的成员变量和成员函数是分开存储的

只有非静态成员变量才属于类的对象上

```c++
#include <iostream>
using namespace std;

//!< 成员变量和成员函数是分开存储的
class Person
{
public:
    int m_a;    //!< 非静态成员变量，属于类的对象上的数据

    static int m_b; //!< 静态成员变量，不属于类的对象上的数据
    void func()     //!< 非静态成员函数，不属于类的对象上的数据
    {
        cout << "func" << endl;
    }

    static void func2() //!< 静态成员函数，不属于类的对象上的数据
    {
        cout << "static func" << endl;
    }

};

int Person::m_b = 100;

void test01()
{
    Person p;
    //!< 空对象，占用内存空间为 1B
    //!< C++ 编译器会给每个空对象也分配一个字节的空间，是为了区分空对象占用内存的位置
    //!< 每个空对象也应该有一个独一无二的内存地址
    cout << "sizeof Person " << sizeof(p) << endl;
}

int main()
{
    test01();
    return 0;
}
```

### 4.3.2 this 指针

通过4.3.1我们知道在C++中成员变量和成员函数是分开存储的

每一个非静态成员函数只会诞生一份函数实例，也就是说多个同类型的对象会公用一块代码

那么问题是：这一块代码是如何区分哪个对象调用自己的呢？ 



C++通过提供特殊的对象指针，this指针，解决上述问题。 **this指针指向被调用的成员函数所属的对象**



this 指针是隐含每一个非静态成员函数内的一种指针

this 指针不需要定义，直接使用即可



this指针的用途：

	1. 当形参和成员变量同名时，可以用this指针来区分
	1. 在类的非静态成员函数中返回对象本身，可以用return *this

```c++
#include <iostream>
using namespace std;

//!< 返回对象本身用 *this
class Person
{
public:
    int age;
    Person(int age)
    {
        //!< this 指针指向的是被调用的成员函数所属的对象
        this->age = age;
    }

    //!< 1. 此处需要使用引用回传
    //!< 2. 不使用引用的回传时，返回值会拷贝构造
    Person& PersonAddAge(const Person& p)
    {
        age += p.age;
        return *this;
    }
};

//!< 解决名称冲突
void test01()
{
    Person p1(18);
    cout << "p1 age: " << p1.age << endl;
}

void test02()
{
    Person p1(10);

    Person p2(10);

    // p2.PersonAddAge(p1);

    // cout << "p2 age " << p2.age << endl;

    //!< 链式编程思想
    p2.PersonAddAge(p1).PersonAddAge(p1).PersonAddAge(p1);
    cout << "p2 age " << p2.age << endl;

}

int main()
{
    test01();
    test02();
    return 0;
}
```

### 4.3.3 空指针访问成员函数

C++中空指针是可以调用成员函数的，但是也要注意有没有用到this指针；

如果用到了this指针，需要加以判断保证代码的健壮性



**示例**

```c++
#include <iostream>
using namespace std;

class Person
{
public:
    void showClassName()
    {
        cout << "class name: Person" << endl;
    }

    void showPersonAge()
    {
        //!< 报错原因，是因为传入的指针为NULL
        if (NULL != this){
            cout << "Person age: " << this->age << endl;
        }
    }
    int age;
};

void test01()
{
    Person* p = NULL;

    p->showClassName();
    //!< this 是一个空指针
    p->showPersonAge();

}

int main()
{
    test01();
    return 0;
}
```

### 4.3.4 const修饰成员函数

**常函数**

1. 成员函数后加 const 修饰后，我们称这个函数为常函数
2. 常函数内不可以修改成员属性
3. 成员属性声明时加关键字mutable后，在常函数中依然可以修改

**常对象**

1. 声明对象前加const修饰，我们称该对象为常对象
2. 常对象只能调用常函数

```c++
#include <iostream>
using namespace std;

class Person
{
public:
    Person()
    {
        
    }
    //!< const Person* const this   //!< 下面的成员函数加了const修饰后，修饰的是this指针，指针指向和值都不可以修改了
    void showPerson() const
    {
        //!< const 修饰后，不可修改
        //!< this 指针的本质是指针常量，指针常量的指向是不可以修改的
        // Person* const this;
        // m_A = 100;
        // this = NULL;        //!< this 指针不可以修改指针的指向
        this->m_B = 10000;            //!< 关键字 mutable 修饰后，在常函数中也可以修改
    }

    void func()
    {

    }

    int m_A;
    mutable int m_B;    //!< 特殊变量，即使在常函数中，也可以修改这个值
};

void test02()
{
    const Person p;     //!< 在对象前加 const，变为常对象
    // p.m_A = 100;        //!< 不可修改
    p.m_B = 100;        //!< 特殊变量，常对象和常函数都可以修改
    p.showPerson();     //!< 常对象只能调用常函数
    // p.func();           //!< 常对象不能调用非常函数
}

int main()
{
    test02();

    return 0;
}
```

## 4.4. 友元

生活中你家有客厅（public），有你的卧室（private）

客厅所有来的客人都可以进去，但是你的卧室是私有的，也就是说只有你能进去；

但是呢，你也可以让你的好闺蜜或者好基友进去



在程序里，有些私有属性，也想让类外特殊的一些函数或者类访问，就需要用到友元的技术



友元的目的就是让一个函数或者类，访问另一个类中的私有成员

友元的关键字 **friend**

友元的三种实现：

1. 全局函数做友元
2. 类做友元
3. 成员函数做友元

### 4.4.1 全局函数做友元

```c++
#include <iostream>
using namespace std;


class Building
{
    //!< goodGay 全局函数是Building的好朋友，可以访问Building中的私有成员
    friend void goodGay(Building* building);
public:
    Building()
    {
        m_SittingRoom = "SittingRoom";
        m_BedRoom = "BedRoom";
    }
    string m_SittingRoom;
private:
    string m_BedRoom;
};

//!< 全局函数
void goodGay(Building* building)
{
    cout << "Good gay's global function access to: " << building->m_SittingRoom << endl;

    cout << "Good gay's global function access to: " << building->m_BedRoom << endl;
}


int main()
{
    Building building;

    goodGay(&building);

    return 0;
}
```

### 4.4.2 类做友元

```c++
#include <iostream>
using namespace std;
#include <string>

class Building;

class Goodgay
{
public:
    void visit();   //!< 参观函数访问Building中的公共和私有属性
    Goodgay();
    Building* building;
};

//!< 类做友元
class Building
{
    friend class Goodgay;   //!< Goodgay 是本类的友元，可以访问本类的私有成员
public:
    Building();
public:
    string m_SittingRoom;

private:
    string m_BedRoom;
};

//!< 类外写成员函数
Building::Building()
{
    m_SittingRoom = "sittingRoom";
    m_BedRoom = "bedRoom";
}

Goodgay::Goodgay()
{
    //创建 Building 对象
    building = new Building;
}

void Goodgay::visit()
{
    cout << "Goodgay is accessing to: " << building->m_SittingRoom << endl;

    cout << "Goodgay is accessing to: " << building->m_BedRoom << endl;
}

void test01()
{
    Goodgay gg;
    gg.visit();
}
    

int main()
{

    test01();
    return 0;
}
```

### 4.4.3 成员函数做友元

```c++
#include <iostream>
using  namespace std;

class Building;

class Goodgay
{
public:
    Goodgay();
    ~Goodgay();
    void visitor();       //!< visit 可以访问Building 中的私有成员
    void visitor2();        //!< visitor 不可以访问Building中的私有成员

    Building* building;
};

class Building
{
    friend void Goodgay::visitor();
public:
    Building();
    ~Building();
    string m_sittingRoom;
private:
    string m_bedRoom;
};

Goodgay::Goodgay()
{
    building = new Building;
}

Goodgay::~Goodgay()
{
    if (NULL != building)
    {
        delete building;
    }
}

Building::Building()
{
    m_sittingRoom = "sittingRoom";
    m_bedRoom = "bedRoom";
}

Building::~Building()
{
    return;
}

void Goodgay::visitor()
{
    cout << "vistor access to " << building->m_sittingRoom << endl;
    cout << "vistor access to " << building->m_bedRoom << endl;
}

void Goodgay::visitor2()
{
    cout << "visitor2 access to " << building->m_sittingRoom << endl;
    // cout << "visitor2 access to " << building->m_bedRoom << endl;    //!< 非友元函数，无法访问Building类中的私有成员
}

void test01()
{
    Goodgay gg;
    gg.visitor();
    gg.visitor2();
}

int main()
{
    test01();
    return 0;
}
```

**示例**

```c++
#include <iostream>
using namespace std;

class Person;

class Student
{
public:
    Student();
    ~Student();
    void GetInformation();
    Person* person;
};

class Person
{
    friend void Student::GetInformation();  //!< 类成员函数做友元
    friend void getInformation(Student* s); //!< 全局函数作为友元
    friend class Student;       //!< 类作为友元，也需要通过类里的成员函数访问

public:
    Person();
    ~Person();
    string m_name;

private:
    int m_age;
};

Student::Student()
{
    person = new Person; 
}

Student::~Student()
{
    if (NULL != person)
    {
        delete person;
    }
}

void Student::GetInformation()
{
    cout << "Person name " << person->m_name << endl;
    cout << "Person age " << person->m_age << endl;
}

Person::Person()
{
    m_name = "zhangsan";
    m_age = 100;
}

Person::~Person()
{
    return;
}

void test01()
{
    Student s;
    s.GetInformation();
}


void getInformation(Student* s)
{
    cout << "Person name: " << s->person->m_name << endl;
    cout << "Person age: " << s->person->m_age << endl;
}

void test02()
{
    Student s;
    getInformation(&s);
}


void test03()
{
    Student s;
    s.GetInformation();
}

int main()
{
    test01();
    test02();
    test03();
    
    return 0;
}
```



## 4.5 运算符重载

运算符重载概念：对已有的运算符重新进行定义，赋予其另一种功能，以适应不同的数据类型。

### 4.5.1 加号运算符重载

作用：实现两个已定义数据类型相加的运算

```c++
#include <iostream>
using namespace std;

//!< 对于内置的数据类型，编译器知道如何运算
//!< 注：成员函数重载和全局函数重载只能保留一个，要不会发生冲突
class Person
{
public:
    int m_A;
    int m_B;
    
    Person();
    Person(int a, int b);
    ~Person();

    //!< 通过自己写一个成员函数，实现两个对象相加属性后返回新的对象
    Person operator+(Person& p);
};

Person Person::operator+(Person& p)
{
    Person temp;
    temp.m_A = this->m_A + p.m_A;
    temp.m_B = this->m_B + p.m_B;
    
    return temp;
}

Person::Person()
{
    cout << "Has no param Person creator called" << endl;
}

Person::Person(int a, int b)
{
    m_A = a;
    m_B = b;
    cout << "Has param Person creator called" << endl;
}

Person::~Person()
{
    cout << "Person destory called" << endl; 
}

//!< 使用成员函数，重载+号运算符
// Person operator+(Person& p1, Person& p2)
// {
//     Person temp;

//     temp.m_A = p1.m_A + p2.m_A;
//     temp.m_B = p1.m_B + p2.m_B;

//     return temp;
// }

//!< 对运算符重载，可以再次重载
Person operator+(Person& p1, int a)
{
    Person temp;

    temp.m_A = p1.m_A + a;
    temp.m_B = p1.m_B + a;

    return temp;
}


void test01()
{
    Person p1(15, 20);
    Person p2(20, 15);

    // Person p3 = p1.operator+(p2);
    //!< 上面的调用方式可以简化为
    Person p3 = p1 + p2;
    cout << "p3.m_A " << p3.m_A << " p3.m_B " << p3.m_B << endl;

    // Person p4 = operator+(p1, p2);
    //!< 上面的调用方式可以简化为：
    Person p4 = p1 + p2;
    cout << "p4.m_A " << p4.m_A << " p4.m_B " << p4.m_B << endl;

    //!< 运算符重载可以发生函数重载
    Person p5 = p1 + 10;
    cout << "p5.m_A " << p5.m_A << " p5.m_B " << p5.m_B << endl;

}



int main()
{
    test01();

    return 0;
}
```

**总结**：

1. 对于内置的数据类型的表达式的运算符是不可能改变的；
2. 不要滥用运算符重载



### 4.5.2 左移运算符重载

作用：可以输出自定义数据类型

```c++
#include <iostream>
using namespace std;

//!< 左移运算符重载
class Person
{
    //!< 全局函数，使用友元函数，可以访问此类的私有成员
    friend ostream& operator<<(ostream& out, Person& p);
public:
    Person();
    Person(int a, int b);
    ~Person();

    //!< 使用成员函数重载，左移运算符，p.operator<<(cout)， 简化版本，p << cout
    //!< 一般不会用成员函数重载左移运算符，因为无法实现 cout 在左边
    // void operator<<()
    // {
        
        
    // }

private:
    int m_A;
    int m_B;
};

Person::Person()
{
    cout << "Has no param Person creator called" << endl;
}

Person::Person(int a, int b)
{
    m_A = a;
    m_B = b;
    cout << "Has param Person creator called" << endl;
}

Person::~Person()
{
    cout << "Person destory called" << endl; 
}

//!< 全局只有一个cout，所以此处要采用 & 的方式返回
ostream& operator<<(ostream& out, Person& p)
{
    out << "m_A: " << p.m_A << " m_B: " << p.m_B;
    return out;
}

void test01()
{
    Person p(100, 1000);
    //!< 链式变成思想，cout << p 返回为cout 即可以再次输出 << 
    cout << p << endl;
}

int main()
{
    test01();
    return 0;
}
```

**总结**：重载左移运算符配合友元可以实现输出自定义数据类型

### 4.5.3 递增运算符重载

作用：通过重载递增运算符，实现自己的整型数据

```c++
#include <iostream>
using namespace std;

// class Person
// {
//     friend Person& operator++();
// public:
//     Person();
//     Person(int a, int b);
//     ~Person();
//     void showInfo();

// private:
//     int m_A;
//     int m_B;
// };

// Person::Person()
// {
//     cout << "Has no param Person creator called" << endl; 
// }

// Person::Person(int a, int b)
// {
//     m_A = a;
//     m_B = b;
//     cout << "Has param Person creator called" << endl;
// }

// Person::~Person()
// {
//     cout << "Person destory called" << endl;
// }

// void Person::showInfo()
// {
//     cout << "m_A: " << this->m_A << " m_B: " << this->m_B << endl; 
// }

// Person& operator++()
// {
//     m_A++;
//     m_B++;

//     return this;
// }

// void test01()
// {
//     Person p1(100, 10);
//     // Person p2 = operator++(p1);
//     p1.operator++();
//     p1.showInfo();
// }

class MyInt
{
    friend ostream& operator<<(ostream& out, MyInt& myint);
public:
    MyInt();

    //!< 重载前置运算符，++i。 此处需要返回引用，需要对一个数据进行操作，否则此处会拷贝，++ 
    MyInt& operator++()
    {
        this->m_Num++;

        return *this;
    }

    //!< 重载后置运算符 i++
    // MyInt operator++(int); int 代表占位参数，用于区分前置和后置
    MyInt operator++(int)
    {
        //!< 先记录当时的结果
        MyInt temp = *this;
        //!< 再递增
        this->m_Num++;
        //!< 最后将记录的结果返回
        return temp;
    }   
private:
    int m_Num;
};

MyInt::MyInt()
{
    m_Num = 0;
}

ostream& operator<<(ostream& out, MyInt& myint)
{
    out << myint.m_Num;

    return out;
}

// //!< 重载前置运算符 ++i
// MyInt& operator++()
// {
//     this->m_num;

//     return *this;
// }

// //!< 重载后置运算符 i++
// void MyInt::operator++()
// {
//     this->m_Num++;
// }

void test01()
{
    MyInt myint;
    cout << ++myint << endl;
    cout << ++myint << endl;
}

void test02()
{
    MyInt myint;

    // cout << (myint++) << endl;
}

int main()
{
    test01();
    test02();
    return 0;
}

```

### 4.5.4 赋值运算符重载

C++至少给一个类添加4个函数：

1. 默认构造函数
2. 默认析构函数
3. 默认拷贝构造函数，对属性值拷贝
4. 赋值运算符 operator=， 对属性进行值拷贝

如果类中有属性指向堆区，做赋值操作时也会出现深浅拷贝的问题

```c++
#include <iostream>
using namespace std;

class Person
{
public:
    Person()
    {

    }
    Person(int age)
    {
        m_age = new int(age);
    }

    ~Person()
    {
        if (NULL != m_age)
        {
            delete m_age;
            m_age = NULL;
        }
    }

    //!< 编译器实现的是浅拷贝函数，如果在析构时释放内存，会出现double free的问题

    //!< 我们自己的实现，在堆区开辟内存，用堆区深拷贝数据
    Person& operator=(Person& p)
    {
        //!< 应该先判断是否有属性在堆区，如果有限释放，再深拷贝
        if (NULL != m_age)
        {
            delete m_age;
            m_age = NULL;
        }

        m_age = new int(*p.m_age);

        return *this;
    }

    int* m_age;
};

void test01()
{
    Person p1(18);
    Person p2(20);
    Person p3(30);

    p3 = p2 = p1;
    
    cout << "p1 age: " << *p1.m_age << endl;
    cout << "p2 age: " << *p2.m_age << endl;
    cout << "p3 age: " << *p3.m_age << endl;

}

int main()
{
    test01();
    return 0;
}
```

### 4.5.5 关系运算符重载

**作用：**重载关系运算符，可以让两个自定义类型对象进行对比操作

```c++
#include <iostream>
using namespace std;


class Person
{
    friend bool operator!=(Person& p1, Person&p2);
public:
    Person();
    Person(string name, int age);
    ~Person();
    bool operator==(Person& p)
    {
        if (this->m_Name == p.m_Name && this->m_Age == p.m_Age)
        {
            return true;
        }
        else
        {
            return false;
        }
    }
    string m_Name;
private:
    int m_Age;
};

Person::Person()
{
    cout << "Default creator called" << endl;
}

Person::Person(string name, int age)
{
    m_Name = name;
    m_Age = age;
    cout << "Has param creator called" << endl;
}

Person::~Person()
{
    cout << "Default destory called" << endl;
}

bool operator!=(Person& p1, Person&p2)
{
    if (p1.m_Name == p2.m_Name && p1.m_Age == p2.m_Age)
    {
        return false;
    }
    return true;
}

void test01()
{
    Person p1("zhangsan", 18);
    Person p2("zhangsan", 18);

    if (p1 == p2)
    {
        cout << "p1 == p2" << endl;
    }
    else
    {
        cout << "p1 != p2" << endl;
    }

    if (p1 != p2)
    {
        cout << "p1 != p2" << endl;
    }
    else
    {
        cout << "p1 == p2" << endl;
    }


    return ;

}


int main()
{
    test01();

    return 0;
}
```

### 4.5.6 函数调用运算符重载

- 函数调用运算符()可以重载

- 由于重载后使用的方式非常像函数的调用，因此成为仿函数

- 仿函数没有固定写法，非常灵活

```c++
#include <iostream>
using namespace std;
#include <string>

class MyPrint
{
public:
    //!< 重载函数调用运算符
    void operator()(string test)
    {
        cout << test << endl;
    }
};

void MyPrint02(string test)
{
    cout << test << endl;
}


void test01()
{
    MyPrint mp;

    //!< 仿函数
    mp("Hello world");

    MyPrint02("Hello world");

    return;
}

//!< 仿函数没有固定的写法，非常灵活
class MyAdd
{
public:
    int operator()(int a, int b)
    {
        return a + b;
    }
};

void test02()
{
    MyAdd myadd;
    int ret = myadd(100, 100);
    cout << ret << endl;

    //!< 匿名函数对象，调用仿函数
    cout << MyAdd()(100, 100) << endl;
}


int main()
{
    test01();
    test02();
    return 0;
}
```

## 4.6 继承

**继承是面向对象的三大特性之一**

有些类与类之间存在特殊关系，例如下图中：

![image-20221026114354627](C:\Users\mengw\AppData\Roaming\Typora\typora-user-images\image-20221026114354627.png)

我们发现，定义这些类的时候，下级别的成员除了拥有上一级的特性，还有自己的特性。

这个时候我们就可以考虑利用继承的技术，减少重复代码。

### 4.6.1 继承的基本语法

例如：我们看到很多网站中，都有公共的头部，公共的底部，甚至公共的左侧列表，只有中心内容不同

接下来我们分别利用普通写法和继承写法来实现网页中的内容，看一下继承存在的意义以及好处。

**语法：**`class  子类 : 继承方式  父类`

**继承的好处**: `减少重复的代码`

**普通实现**

```c++
#include <iostream>
using namespace std;

//!< 普通页面实现

//!< Java页面
// class Java
// {
// public:
//     void header()
//     {
//         cout << "首页、公开课、登录、注册...(公共头部)" << endl;
//     }
//     void footer()
//     {
//         cout << "帮助中心、交流中心、站内地图...(公共底部)" << endl;
//     }
//     void left()
//     {
//         cout << "Java、Python、C++...(公共分类列表)" << endl;
//     }
//     void content()
//     {
//         cout << "Java 学科视频" << endl;
//     }

// };

// class Python
// {
// public:
//     void header()
//     {
//         cout << "首页、公开课、登录、注册...(公共头部)" << endl;
//     }
//     void footer()
//     {
//         cout << "帮助中心、交流中心、站内地图...(公共底部)" << endl;
//     }
//     void left()
//     {
//         cout << "Java、Python、C++...(公共分类列表)" << endl;
//     }
//     void content()
//     {
//         cout << "Python 学科视频" << endl;
//     }
// };

// class CPP
// {
// public:
//     void header()
//     {
//         cout << "首页、公开课、登录、注册...(公共头部)" << endl;
//     }
//     void footer()
//     {
//         cout << "帮助中心、交流中心、站内地图...(公共底部)" << endl;
//     }
//     void left()
//     {
//         cout << "Java、Python、C++...(公共分类列表)" << endl;
//     }
//     void content()
//     {
//         cout << "C++ 学科视频" << endl;
//     }
// };

//!< 继承的好处：减少重复的代码
//!< 语法：class 子类 : 继承方式 父类
//!< 子类也成为派生类，父类也成为基类

//!< 继承实现
class BasePage
{
public:
    void header()
    {
        cout << "首页、公开课、登录、注册...(公共头部)" << endl;
    }
    void footer()
    {
        cout << "帮助中心、交流中心、站内地图...(公共底部)" << endl;
    }
    void left()
    {
        cout << "Java、Python、C++...(公共分类列表)" << endl;
    }
};

class Java : public BasePage
{
public:
    void content()
    {
        cout << "Java 学科视频" << endl;
    }
};

class Python : public BasePage
{
public:
    void content()
    {
        cout << "Python 学科视频" << endl;
    }
};

class CPP : public BasePage
{
public:
    void content()
    {
        cout << "C++ 学科视频" << endl;
    }
};

void test01()
{
    cout << "Java 下载视频页面如下：" << endl;
    Java java;
    java.header();
    java.footer();
    java.left();
    java.content();

    cout << "Python 下载视频页面如下：" << endl;
    Python python;
    python.header();
    python.footer();
    python.left();
    python.content();

    cout << "C++ 下载视频页面如下：" << endl;
    CPP cpp;
    cpp.header();
    cpp.footer();
    cpp.left();
    cpp.content();
}

int main()
{
    test01();
    return 0;
}
```



**继承实现**



### 4.6.2. 继承方式

继承的语法：`class 子类: 继承方式  父类`

**继承方式一共有三种**

 - 公共继承

 - 保护继承

 - 私有继承

   ![image-20221026181637558](C:\Users\mengw\AppData\Roaming\Typora\typora-user-images\image-20221026181637558.png)

   ```c++
   #include <iostream>
   using namespace std;
   
   class Base1
   {
   public:
       int m_A;
   protected:
       int m_B;
   private:
       int m_C;
   };
   
   class Son1: public Base1
   {
   public:
       void func();
   };
   
   void Son1::func()
   {
       //!< 父类中公共权限属性，在子类中仍然为公共权限
       m_A = 10;
       //!< 父类中保护权限属性，在子类中仍然为保护权限
       m_B = 100;
       //!< 父类中私有权限属性，子类不可访问
       // m_C = 200;
   
       cout << "m_A: " << m_A << " m_B: " << m_B << endl;
   }
   
   void test01()
   {
       Son1 s1;
       s1.func();
       s1.m_A = 1000;
       //!< 保护权限类外不能访问，类内可以访问
       // s1.m_B = 1000;
   }
   
   class Base2
   {
   public:
       int m_A;
   protected:
       int m_B;
   private:
       int m_C;
   };
   
   class Son2:protected Base2
   {
   public:
       void func();
   };
   
   void Son2::func()
   {
       //!< 父类中公共权限的属性，保护继承后在子类中变为保护权限
       m_A = 1000;
       //!< 父类中保护权限的属性，保护集成后在子类仍然为保护权限
       m_B = 10000;
       //!< 父类中的私有权限属性，子类中不能访问
       // m_C = 1000;
   }
   
   void test02()
   {
       Son2 s2;
       // //!< 保护权限属性，类外不能访问
       // s2.m_A = 1000;
       // //!< 保护权限属性，类外不能访问
       // s2.m_B = 200;
       // //!< 私有权限属性，不能访问
       // s2.m_C = 2000;
   }
   
   class Base3
   {
   public:
       int m_A;
   protected:
       int m_B;
   private:
       int m_C;
   };
   
   class Son3:private Base3
   {
   public:
       void func();
   };
   
   class GrandSon:public Son3
   {
   public:
       void func();
   };
   
   void Son3::func()
   {
       //!< 私有继承后，权限变为私有，只有类内能访问
       m_A = 1000;
       //!< 私有继承后，权限变为私有，只有类内能访问
       m_B = 1000;
       // m_C = 1000;
   }
   
   void test03()
   {
       Son3 s3;
       s3.func();
   }
   
   void GrandSon::func()
   {
       //!< 私有属性被公有继承后，在类内是无法访问的
       // m_A = 1000;
       // m_B = 1000;
   }
   
   int main()
   {
       test01();
       return 0;
   }
   ```

   

### 4.6.3 继承中的对象模型

**问题**：从父类继承过来的成员，哪些属于子类对象中？

```c++
#include <iostream>
using namespace std;

//!< 继承中的对象模型
class Base
{
public:
    int m_A;
protected:
    int m_B;
private:
    int m_C;
};

//!< 父类中，所有的非静态成员属性，都会被子类继承
//!< 父类中，私有的成员属性是被编译器隐藏了，因此访问不到，但确实被继承了
class Son:public Base
{
public:
    int m_D;
};

void test01()
{
    //!< 4/12/16   结果 16
    cout << sizeof(Son) << endl;
}

int main()
{
    test01();
    return 0;

}
```



### 4.6.4 继承中的构造和析构顺序

子类继承了父类之后，当创建子类对象，也会调用父类的构造函数。

**问题：**父类和子类的构造和析构顺序是谁先谁后？

```c++
#include <iostream>
using namespace std;

class Base
{
public:
    Base();
    ~Base();
};

class Son:public Base
{
public:
    Son();
    ~Son();
};

Base::Base()
{
    cout << "Base has no param creator called" << endl;
}

Base::~Base()
{
    cout << "Base's destory called" << endl;
}

Son::Son()
{
    cout << "Son has no param creator called" << endl;
}

Son::~Son()
{
    cout << "Son's destory called" << endl;
}

void test01()
{
    // Base b;
    //!< 继承中的构造和析构的顺序
    //!< 先构造父类，再构造子类，析构的顺序相反
    Son s;
}

int main()
{
    test01();

    return 0;
}
```



### 4.6.5 继承同名成员处理方式

问题：当父类和子类出现同名的成员，如何通过子类对象，访问到子类和父类中同名的数据呢？ 

- 访问子类同名成员，直接访问即可，用  `.` 的方式
- 访问父类同名成员，需要加作用域  `类名::成员`

```c++
#include <iostream>
using namespace std;

class Base
{
public:
    int m_A;
    Base()
    {
        m_A = 100;
    }
    void func()
    {
        cout << "Base test" << endl;
    }
    void func(int a)
    {
        cout << "Base test int a" << endl;
    }
protected:
    int m_B;
private:
    int m_C;
};

class Son:public Base
{
public:
    int m_A;
    Son()
    {
        m_A = 200;
    }
    void func()
    {
        cout << "Son test" << endl;
    }
};

void test01()
{
    Son s;
    cout << "s.m_A: " << s.m_A << endl;
    //!< 如果通过子类对象，访问父类中的同名成员，需要加上作用域
    cout << "s.Base::m_A " << s.Base::m_A << endl;
}

void test02()
{
    Son s;
    s.func();
    s.Base::func();
    //!< 如果子类中出现和父类同名的成员函数，子类的同名成员会隐藏掉父类中所有同名成员函数
    //!< 如果子类想访问父类中被隐藏掉的同名成员函数，需要加作用域
    s.Base::func(100);
}

int main()
{
    test01();
    test02();

    return 0;
}
```

**总结**

- 子类对象可以直接访问到子类中的同名成员
- 子类对象加作用域可以访问父类中的同名成员
- 当子类与父类拥有同名的成员函数，子类会隐藏父类中的同名成员函数，加作用域可以访问到父类中的同名成员函数

### 4.6.6 继承同名静态成员处理方式

问题：继承中同名的静态成员在子类对象上如何访问？

静态成员和非静态成员同名，处理方式一致。

- 访问子类同名成员，直接访问即可
- 访问父类同名成员，需要加作用域

**示例**

```c++
#include <iostream>
using namespace std;

class Base
{
public:
    static int m_A;
    static void func();
};

int Base::m_A = 100;
void Base::func()
{
    cout << "Base static func" << endl;
}

class Son:public Base
{
public:
    static int m_A;
    static void func();
};

int Son::m_A = 200;
void Son::func()
{
    cout << "Son static func" << endl;
}

void test01()
{
    //!< 通过对象的方式访问静态成员
    Son s;
    cout << "Son m_A: " << s.m_A << endl;
    cout << "Base m_A: " << s.Base::m_A << endl;

    s.func();
    s.Base::func();

    //!< 通过类名的方式访问静态成员
    cout << "Son m_A: " << Son::m_A << endl;
    //<! 第一个 :: 代表通过类名的方式访问，第二个 :: 代表访问父类作用域下的成员
    cout << "Base m_A: " << Son::Base::m_A << endl;
    Son::func();
    Son::Base::func();
}

int main()
{
    test01();

    return 0;
}
```



### 4.6.7 多继承语法

C++中允许**一个类继承多个类**

语法：`class 子类: 继承方式 父类1, 继承方式 父类2 ...`

多继承可能引发父类中同名成员的出现，需要加作用域区分

**C++实际开发中不建议用多继承**

```c++
#include <iostream>
using namespace std;

class Base1
{
public:
    int m_A;
    Base1()
    {
        m_A = 100;
    }
};

class Base2
{
public:
    int m_A;
    Base2()
    {
        m_A = 200;
    }
};

class Son:public Base1, public Base2
{
public:
    int m_C;
    int m_D;
    Son()
    {
        m_C = 300;
        m_D = 400;
    }
};

void test01()
{
    Son s;
    cout << sizeof(s) << endl;
    cout << "Base1::m_A: " << s.Base1::m_A << endl;
    cout << "Base2::m_A: " << s.Base2::m_A << endl;

}

int main()
{
    test01();
    return 0;
}
```

- 总结：多继承中如果父类出现同名成员，需要通过作用域来访问

### 4.6.8 菱形继承 

**菱形继承的概念：**

​	两个派生类继承同一个基类

​	又有某个类同时继承了这两个派生类

​	这种继承被称为菱形继承，或者钻石继承

**典型的菱形继承案例：**

![image-20221027095956441](C:\Users\mengw\AppData\Roaming\Typora\typora-user-images\image-20221027095956441.png)

**菱形继承问题：**

	- 羊继承了动物的数据，驼同样继承了动物的数据，当草泥马使用数据时，就会产生二义性
	- 草泥马继承自动物的数据继承了两份，其实我们清楚，这份数据我们只需要一份即可

```c++
#include <iostream>
using namespace std;

class Animal
{
public:
    int m_Age;
};

//!< 利用虚继承可以解决菱形继承的问题
//!< 在继承前面加上virtual，变为虚继承
//!< Anmial 类为虚基类
class Sheep:virtual public Animal
{
public:

};

class Tuo:virtual public Animal
{
public:

};

class SheepTuo:public Sheep, public Tuo
{
public:
};

void test01()
{
    SheepTuo st;

    st.Sheep::m_Age = 99;
    st.Tuo::m_Age = 89;

    //!< 当菱形继承的时候，两个父类拥有相同的数据，需要加以作用域区分
    cout << "st.Sheep::m_Age: " << st.Sheep::m_Age << endl;
    cout << "st.Tuo::m_Age: " << st.Tuo::m_Age << endl;
    cout << "st.m_Age: " << st.m_Age << endl;

    //!< 这份数据我们只需要一份，菱形继承导致这份数据有两份，资源浪费
    cout << sizeof(st) << endl;

}

int main()
{
    test01();

    return 0;
}
```



## 4.7 多态

### 4.7.1 多态的基本语法

**多态是C++面向对象三大特性之一**

多态分为两类：

- 静态多态：函数重载和运算符重载属于静态多态，复用函数名
- 动态多态：派生类和虚函数实现运行时多态

静态多态和动态多态的区别：

- 静态多态的函数地址早绑定 - 编译阶段确定函数地址
- 动态多态的函数地址晚绑定 - 运行阶段确定函数地址

下面通过案例来讲解多态：

```c++
#include <iostream>
using namespace std;

class Animal
{
public:
    virtual void speak()
    {
        cout << "Animal are speaking~~~" << endl;
    }
};

class Cat:public Animal
{
public:
    //!< 重写 函数的返回值类型和参数列表完全相同
    void speak()
    {
        cout << "Cat are speaking~~~" << endl;
    }
};

class Dog:public Animal
{
public:
    void speak()
    {
        cout << "Dog are speaking~~~" << endl;
    }
};

//!< 执行说话的函数
//!< 地址早绑定，在编译阶段就确定了函数的地址为 Animal下的speak函数，无虚函数的情况
//!< 如果想执行 Cat类下的speak，此地址就不能早绑定，需要在运行时绑定，即：地址晚绑定;  父类里的speak变为虚函数，就可以访问子类里的speak函数了

//!< 动态多态的满足条件：
//!< 1. 有继承关系
//!< 2. 子类重写父类的函数，例如：这里子类重写了speak函数

//!< 动态多态的使用：
//!< 父类的指针或引用，指向子类的对象
void doSpeak(Animal& animal)    //!< Animal& = Cat;
{
    animal.speak();
}

void test01()
{
    Cat cat;
    doSpeak(cat);

    Dog dog;
    doSpeak(dog);
}

int main()
{
    test01();
    return 0;
}
```

**总结**

- 动态多态的满足条件：

  - 有继承关系

  - 子类重写父类的函数，例如：这里子类重写了speak函数

- 动态多态的使用：

  - 父类的指针或引用，指向子类的对象

- 重写 函数的返回值类型和参数列表完全相同

### 4.7.2 案例1 计算器类

案例描述：

​	分别用普通写法和多态技术，设计实现两个操作数进行运算的计算器

多态的优点：

- 代码组织结构清晰
- 可读性强
- 利于前期和后期的扩展以及维护

```c++
#include <iostream>
using namespace std;
#include <string>

// //!< 普通写法
// class Calculator
// {
// public:
//     int getResult(string oper)
//     {
//         if ("+" == oper)
//         {
//             return m_Num1 + m_Num2;
//         }
//         else if ("=" == oper)
//         {
//             return m_Num1 - m_Num2;
//         }
//         else if ("*" == oper)
//         {
//             return m_Num1 * m_Num2;
//         }
//         return 0;
//         //!< 如果想扩展新的功能，需要增加源码
//         //!< 在真实的开发中，提供开闭原则，
//             //!< 对扩展进行开放，对修改进行关闭
//     }

//     int m_Num1;     //!< 操作数1
//     int m_Num2;     //!< 操作数2
// };

// void test01()
// {
//     Calculator c;
//     c.m_Num1 = 10;
//     c.m_Num2 = 10;

//     cout << "c.m_Num1 + c.m_Num2 = " << c.getResult("+") << endl;
// }

//!< 多态写法
//!< 多态的好处
//!< 1. 组织结构清晰
//!< 2. 可读性强
//!< 3. 对于前期和后期的扩展以及维护性强
class AbstractCalculator
{
public:
    //!< 多态的实现，需要在子类重写，所以此处需要用virtual修饰
    virtual int getResult()
    {
        return 0;
    }
    int m_Num1;
    int m_Num2;
};

class AddCalculator:public AbstractCalculator
{
public:
    //!< 重写成员函数，实现数字相加
    int getResult()
    {
        return m_Num1 + m_Num2;
    }
};

class SubCalculator:public AbstractCalculator
{
public:
    //!< 重写成员函数，实现数字相减
    int getResult()
    {
        return m_Num1 - m_Num2;
    }
};

class MulCalculator:public AbstractCalculator
{
public:
    //!< 重写成员函数，实现数字相乘
    int getResult()
    {
        return m_Num1 * m_Num2;
    }
};

class DivisionCalculator:public AbstractCalculator
{
public:
    //!< 重写成员函数，实现数字相乘
    int getResult()
    {
        if (0 != m_Num2)
        {
            return m_Num1 / m_Num2;
        }

        return -1;
    }
};

void test02()
{
    //!< 多态的使用条件
    //!< 父类的指针或者引用指向子类的对象
    AbstractCalculator* abc = NULL;
    //!< 创建父类对象，使用子类对象new
    abc = new AddCalculator;
    abc->m_Num1 = 10;
    abc->m_Num2 = 20;
    cout << "abc->m_Num1 + abc->m_Num2 = " << abc->getResult() << endl;
    delete abc;

    abc = new SubCalculator;
    abc->m_Num1 = 20;
    abc->m_Num2 = 10;
    cout << "abc->m_Num1 - abc->m_Num2 = " << abc->getResult() << endl;
    delete abc;

    abc = new MulCalculator;
    abc->m_Num1 = 100;
    abc->m_Num2 = 100;
    cout << "abc->m_Num1 * abc->m_Num2 = " << abc->getResult() << endl;
    delete abc;
}


int main()
{
    // test01();
    test02();
    return 0;
}
```

**总结：**C++开发提倡利用多态设计程序架构，以为多态优点很多

### 4.7.3 纯虚函数和抽象类

在多态中，通常父类中虚函数的实现是毫无意义的，主要都是调用子类重写的内容。

因此可以将虚函数改为 **纯虚函数**

纯虚函数语法：`virtual 返回值类型 函数名 (参数列表) = 0;`

当类中有了纯虚函数，这个类也成为 **抽象类**

**抽象类的特点：**

- 无法实例化对象
- 子类必须重写抽象类中的纯虚函数，否则也属于抽象类

示例：

```c++
#include <iostream>
using namespace std;

class AbstractCalculator
{
public:
    //!< 纯虚函数
    //!< 只要有一个纯虚函数，这个类成为抽象类
    //!< 抽象类的特点
    //!< 1. 无法实例化对象
    //!< 2. 抽象类的子类，必须要重写父类中的纯虚函数，否则也属于抽象类
    virtual int getResult(int a, int b) = 0;
    int m_A;
    int m_B;
};

class AddCalculator:public AbstractCalculator
{
public:
    virtual int getResult(int a, int b)
    {
        return m_A + m_B + a + b;
    }
};

class SubCalculator:public AbstractCalculator
{
public:
    virtual int getResult(int a, int b)
    {
        return m_A - m_B - a - b;
    }
};

class MulCalculator:public AbstractCalculator
{
public:
    virtual int getResult(int a, int b)
    {
        return m_A * m_B * a * b;
    }
};

int calculator(AbstractCalculator& abc, int a, int b)
{
    return abc.getResult(a, b);
}

void test01()
{
    // AbstractCalculator abc;  //!< 抽象类是无法实例化对象的
    // new AbstractCalculator;

    // AddCalculator add;
    // add.m_A = 1000;
    // add.m_B = 1000;
    // int a = 10;
    // int b = 10;
    // cout << calculator(add, a, b) << endl;

    AbstractCalculator* abc = new AddCalculator;
    abc->m_A = 10;
    abc->m_B = 10;
    int a = 10;
    int b = 10;
    cout << abc->getResult(a, b) << endl;
}

int main()
{
    test01();
    return 0;
}
```

### 4.7.4 多态案例二-制作饮品

**案例描述：**

​	制作流程的大致流程为：煮水 - 冲泡 - 倒入杯中 - 加入辅料

​	利用多态技术实现本案例，提供抽象制作饮品基类，提供子类制作咖啡和茶叶。

![image-20221028110736508](C:\Users\mengw\AppData\Roaming\Typora\typora-user-images\image-20221028110736508.png)

示例：

```c++
#include <iostream>
using namespace std;

// class MakingDrinks
// {
// public:
//     virtual void BoilWater_F() = 0;
//     virtual void ImportTheCup_F() = 0;
//     virtual void MakingDrinks_F() = 0;
// };

// class Coffee: public MakingDrinks
// {
// public:
//     void BoilWater_F()
//     {
//         cout << "1. Making coffee one step: boil the water!!! " << endl;
//     }

//     void BrewedCoffee_F()
//     {
//         cout << "2. Making coffee second step: brewed coffee!!! " << endl;
//     }
    
//     void ImportTheCup_F()
//     {
//         cout << "3. Making coffee third step: import the cup!!! " << endl;
//     }

//     void AddSugar()
//     {
//         cout << "4. Making coffee fourth step: add sugar!!! " << endl;
//     }

//     void AddMilk()
//     {
//         cout << "5. Making coffee fifth step: add milk!!! " << endl;
//     }

//     void MakingDrinks_F()
//     {
//         BoilWater_F();
//         BrewedCoffee_F();
//         ImportTheCup_F();
//         AddSugar();
//         AddMilk();
//     }

// };

// class Tea: public MakingDrinks
// {
// public:
//     void BoilWater_F()
//     {
//         cout << "1. Making tea one step: boil the water!!! " << endl;
//     }

//     void BrewedTea_F()
//     {
//         cout << "2. Making tea second step: brewed tea!!! " << endl;
//     }

//     void ImportTheCup_F()
//     {
//         cout << "3. Making tea third step: import the cup!!! " << endl;
//     }

//     void AddLemon()
//     {
//         cout << "4. Making tea fourth step: add lemon!!! " << endl;
//     }
//     void MakingDrinks_F()
//     {
//         BoilWater_F();
//         BrewedTea_F();
//         ImportTheCup_F();
//         AddLemon();
//     }
// };


// void test01()
// {
//     MakingDrinks* drinks = new Coffee;
//     drinks->MakingDrinks_F();
//     delete drinks;

//     drinks = new Tea;
//     drinks->MakingDrinks_F();
//     delete drinks;
    
// }

class AbstractDrinking
{
public:
    virtual void BoilWater() = 0;
    virtual void Brew() = 0;
    virtual void PourInCup() = 0;
    virtual void PutSomething() = 0;
    virtual void MakeDrink()
    {
        BoilWater();
        Brew();
        PourInCup();
        PutSomething();
    }
};

class Coffee:public AbstractDrinking
{
public:
    virtual void BoilWater()
    {
        cout << "Make coffee Boil water......" << endl;
    }
    virtual void Brew()
    {
        cout << "Make coffee Brew coffee...... " << endl; 
    }
    virtual void PourInCup()
    {
        cout << "Make coffee Pour in cup...... " << endl;
    }
    virtual void PutSomething()
    {
        cout << "Make coffee Put sugar & milk......" << endl;
    }
};

class Tea:public AbstractDrinking
{
    public:
    virtual void BoilWater()
    {
        cout << "Make Tea Boil water......" << endl;
    }
    virtual void Brew()
    {
        cout << "Make Tea Brew tea...... " << endl; 
    }
    virtual void PourInCup()
    {
        cout << "Make Tea Pour in cup...... " << endl;
    }
    virtual void PutSomething()
    {
        cout << "Make Tea Put lemon......" << endl;
    }
};

void adm_doWork(AbstractDrinking* makeDrink)
{
    makeDrink->MakeDrink();
}

void test01()
{
    AbstractDrinking* coffee = new Coffee;
    adm_doWork(coffee);
    delete coffee;

    AbstractDrinking* tea = new Tea;
    adm_doWork(tea);
    delete tea;
}

int main()
{
    test01();
    return 0;
}
```

### 4.7.5 虚析构和纯虚析构

多态使用时，如果子类中有属性开辟到堆区，那么父类指针在释放时，无法调用到子类的析构代码

解决方式：将父类中的析构函数改为 **虚析构** 或者 **纯虚析构**

虚析构和纯虚析构的特性：

- 可以解决父类指针释放子类对象
- 都需要具体的函数实现

虚析构和纯虚析构的区别：

- 如果是纯虚析构，该类属于抽象类，无法实例化对象

虚析构语法：
`virtual ~类名() {}`

纯虚析构语法：

`virtual ~类名() = 0;`

**总结：**

1. 虚析构和纯虚析构就是用来解决通过父类指针释放子类对象
2. 如果子类中没有堆区数据，可以不写为虚析构或纯虚析构
3. 拥有纯虚析构函数的类也属于抽象类
4. 虚析构和纯虚析构只能有一个存在
5. 纯虚析构在类中声明后，需要在类外实现；

```c++
#include <iostream>
using namespace std;

class Animal
{
public:
    Animal()
    {
        cout << "Animal's creator called" << endl;
    }
    //!< 利用虚析构可以解决父类指针释放子类对象释放不干净的问题
    // virtual ~Animal()
    // {
    //     cout << "Animal's destory called " << endl;
    // }
    //!< 纯虚析构, 需要声明也需要实现
    //!< 有了纯虚析构之后，这个类也属于抽象类，无法实例化对象
    virtual ~Animal() = 0;
    virtual void speak() = 0;
    string* m_Name;
};

Animal::~Animal()
{
    cout << "Animal's virtual destory called " << endl;
}

class Cat:public Animal
{
public:
    Cat(string name)
    {
        cout << "Cat's creator called" << endl;
        m_Name = new string(name);
    }

    virtual void speak()
    {
        cout << "Cat: "<< *m_Name << " is speaking" << endl; 
    }
    ~Cat()
    {
        if (NULL != m_Name)
        {
            cout << "Cat's destory called" << endl;
            delete m_Name;
            m_Name = NULL;
        }
    }
};

void test01()
{
    Animal* a = new Cat("Tom");
    a->speak();
    //!< 父类的指针在析构的时候，不会调用子类中的析构，导致子类如果有堆区属性，出现内存泄漏
    delete a;
}

int main()
{
    test01();
    return 0;
}
```

### 4.7.5 多态案例三-电脑组装

**案例描述：**

- 电脑主要组成部件为CPU（用于计算）、显卡（用于显示）、内存条（用于存储）
- 将每个部件封装出抽象基类，并且提供不同的厂商生产不同的零件，例如：Intel厂商和Lenovo厂商
- 创建电脑类提供让电脑工作的函数，并且调用每个零件工作的接口
- 测试组装三台不同的电脑进行工作

```c++
#include <iostream>
using namespace std;

//!< 创建零件基类，CPU
class CPU
{
public:
    //!< 拥有计算能力
    virtual void calculate() = 0;
    //!< 算力
    virtual void hertz() = 0;
    long long int m_hertz;
};

//!< 创建显卡基类，VideoCard
class VideoCard
{
public:
    //!< 拥有显示的能力
    virtual void display() = 0;
    //!< 算力
    virtual void hertz() = 0;
    double m_size; //!< GB
};

//!< 创建内存基类，Memroy
class Memroy
{
public:
    //!< 用于存储的能力
    virtual void storage() = 0;
    //!< 存储空间，单位：GB
    virtual void spaceSize() = 0;
    double m_size;
};

//!< 电脑的基类
class Computer
{
public:
    Computer(CPU* cpu, VideoCard* vc, Memroy* mm, string* name)
    {
        this->m_CPU = cpu;
        this->m_Mm = mm;
        this->m_Vc = vc;
        this->name = name;
    }
    ~Computer()
    {
        cout << "Computer's destory called" << endl;
        if (NULL != this->m_CPU) 
        {
            delete this->m_CPU;
            this->m_CPU = NULL;
        }

        if (NULL != this->m_Mm)
        {
            delete this->m_Mm;
            this->m_Mm = NULL;
        }

        if (NULL != this->m_Vc)
        {
            delete this->m_Vc;
            this->m_Vc = NULL;
        }
        
        if (NULL != this->name)
        {
            delete this->name;
            this->name = NULL;
        }

    }

    void doWork()
    {
        cout << "This " << *this->name << " is working......" << endl;
        this->m_CPU->calculate();
        this->m_CPU->hertz();
        this->m_Mm->spaceSize();
        this->m_Mm->storage();
        this->m_Vc->hertz();
        this->m_Vc->display();
    }

private:
    CPU* m_CPU;
    VideoCard* m_Vc;
    Memroy* m_Mm;
    string* name;
};

class IntelCPU:public CPU
{
public:
    IntelCPU(long long int hertzSize)
    {
        this->m_hertz = hertzSize;
    }
    //!< 拥有计算能力
    virtual void calculate()
    {
        cout << "Intel cpu is calculate ing ..." << endl;
    }
    //!< 算力
    virtual void hertz()
    {
        cout << "Intel cpu hertz " << this->m_hertz << "HZ" << endl;
    }
};

class IntelVideoCard:public VideoCard
{
public:
    IntelVideoCard(double size)
    {
        m_size = size;
    }
    //!< 拥有显示的能力
    virtual void display()
    {
        cout << "Intel video card is working..." << endl;
    }
    //!< 算力
    virtual void hertz()
    {
        cout << "Intel video card hertz: " << this->m_size << " GB" << endl;
    } 
};

class IntelMemroy:public Memroy
{
public:
    IntelMemroy(double size)
    {
        m_size = size;
    }
    //!< 拥有显示的能力
    virtual void storage()
    {
        cout << "Intel Memroy is working..." << endl;
    }
    //!< 算力
    virtual void spaceSize()
    {
        cout << "Intel Memroy hertz: " << this->m_size << " GB" << endl;
    }
};

class DellCPU:public CPU
{
public:
    DellCPU(long long int hertzSize)
    {
        this->m_hertz = hertzSize;
    }
    //!< 拥有计算能力
    virtual void calculate()
    {
        cout << "Dell cpu is calculate ing ..." << endl;
    }
    //!< 算力
    virtual void hertz()
    {
        cout << "Dell cpu hertz " << this->m_hertz << "HZ" << endl;
    }
};

class DellVideoCard:public VideoCard
{
public:
    DellVideoCard(double size)
    {
        m_size = size;
    }
    //!< 拥有显示的能力
    virtual void display()
    {
        cout << "Dell video card is working..." << endl;
    }
    //!< 算力
    virtual void hertz()
    {
        cout << "Dell video card hertz: " << this->m_size << " GB" << endl;
    } 
};

class DellMemroy:public Memroy
{
public:
    DellMemroy(double size)
    {
        m_size = size;
    }
    //!< 拥有显示的能力
    virtual void storage()
    {
        cout << "Dell Memroy is working..." << endl;
    }
    //!< 算力
    virtual void spaceSize()
    {
        cout << "Dell Memroy hertz: " << this->m_size << " GB" << endl;
    }
};


void test01()
{
    //!< 组装第一台电脑，先构建零件
    CPU* cpu = new IntelCPU(1024);
    VideoCard* vc = new IntelVideoCard(2);
    Memroy* mm = new IntelMemroy(256);
    string* name = new string("Intel");

    Computer* pc = new Computer(cpu, vc, mm, name);
    pc->doWork();
    delete pc;

    cout << "-----------------------------------------------------------------" << endl;

    Computer*pc1 = new   Computer(new DellCPU(2048), new DellVideoCard(4), new DellMemroy(512), new string("Dell"));
    pc1->doWork();
    delete pc1;
}

int main()
{
    test01();
    return 0;
}
```

