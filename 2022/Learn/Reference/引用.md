[TOC]

# 学习引用

## 引用的基本语法

1. 引用是变量的别名;
2. 引用变量的类型和原名变量的类型需要保持一致;
3. 引用变量的定义需要在变量前加上 & 符号;
4. 引用变量和原名变量操作的是同一块内存，使用引用变量对变量的值进行修改同样生效;
6. 引用变量的定义需要初始化，即: 引用变量定义时需要初始化原名;
7. 引用一旦初始化后，就不可以更改，即:不能再作为其他变量的别名;

```c++
int main()
{
    int a = 10;
    int &b = a;
    int c = 10000;

    cout << "a = " a << endl;
    cout << "b = " b << endl;   //!< a 和 b 一样输出都为10

    b = 100;
    cout << "a = " a << endl;
    cout << "b = " b << endl;   //!< a 和 b 一样输出都为100

    b = c;  //!< 这里的 = 是赋值操作，而不是对引用更改;

    cout << "a = " a << endl;
    cout << "b = " b << endl;
    cout << "c = " c << endl;   //!< 此处 a = b = c = 10000

    return 0;
}
```

## 引用做函数参数

1. 值传递
2. 地址传递
3. 引用传递
4. 引用和地址传递的效果是一样的，但是引用的语法更简单，也更清楚；

```c++
/** 值传递的方式，函数内使用的是局部变量，形参会交换数据，但不会对实参做交换 */
void swapValue(int a, int b)
{
    int temp = 0;
    temp = a;
    a = b;
    b = temp;
}

/** 地址传递的方式，函数内部使用的传入实参的地址，对实参的地址操作，可以对实参进行交换 */
void swapAddress(int *a, int *b)
{
    int temp = 0;
    temp = *a;
    *a = *b;
    *b = temp;
}

/** 引用传递的方式，函数内部使用的是实参的别名的方式，操作的是实参的地址，因此可以对实参进行交换 */
void swapReference(int &b, int &b)
{
    int temp = 0;
    temp = a;
    a = b;
    b = a;
}

int main()
{
    int a = 10;
    int b = 20;

    swapReference(a ,b);

    return 0;
}
```

## 引用做函数的返回值

1. 不要返回局部变量的引用；
2. 函数的调用可以作为左值；

```c++
/** 不能返回局部变量的引用 */
int& func1()
{
    //!< 此处是错误的，不能返回局部变量的引用
    int a = 10;
    return a;
}

/** 函数调用可以作为左值 */
int& func2()
{
    //!< 静态变量存放在全局区，程序结束后系统才会释放
    static int a = 10;
    return a;
}

int main()
{
    // int& ref = func1();
    // cout << "ref = " << ref << endl;

    int& ref = func2();
    cout << "ref = " << ref << endl;    //!< 输出为10

    /** 1. func2 调用完成后返回的是 a 的引用;
        2. 这里对a的引用赋值为1000
        3. ref 也是 a的别名，所以也是1000
        4. 如果函数的返回值是个引用，那么函数的调用可以作为左值，且被赋值； */
    func2() = 1000;
    cout << "ref = " << ref << endl;    //!< 输出为 1000

    reutrn 0;
}
```

## 引用的本质

1. 引用的本质在C++内部实现是一个指针常量；

```c++
int main()
{
    int a = 10;

    //!< 编译器会自动转换为，int * const ref = &a; 指针常量是指针的指向不可修改，也说明了引用的指向不可更改；
    int& ref = a;

    ref = 20;   //!< 内部发现ref是一个引用，会自动转换为 *ref = 20;
}
```

## 常量引用

1. 常量引用一般用于修饰形参，防止误操作
2. 引用必须引一块合法的内存空间
    1. 例如：int& a = 10; //!< 此处是不被允许的
    2. 例如：const int& ref = 10; //!< 此处是被允许的，编译器会转换为：int temp = 10;  const int& ref = temp;